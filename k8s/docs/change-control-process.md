### Spack Infrastructure Change Control Process

This document details the change control process for the spack infrastructure
repository and explains the parts thereof that are automated by the various
software components installed on the kubernetes cluster.

#### 0 - Development and Iteration

Although this change control process is centered around a single git repository,
the contents are not "developed" in the same way that a code base would be.  We
try to keep the process similar where possible for the sake of familiarity, but
deviate where necessary.

For example, there is no complete analog for local development and testing; only
incomplete approaches with various tradeoffs.

 - You could stand up your own local kubernetes cluster using something like
   [minikube](https://minikube.sigs.k8s.io/docs/) or
   [kind](https://kind.sigs.k8s.io/) and iterate on that, but there are a number
   of facilities that are hard or impossible to reproduce locally, such as DNS
   and certificate management.  Also, many of the file contents in this repo
   contain portions that are specific to the production cluster, and would
   likely not work for a local development cluster without modification.

 - You could deploy resources that you are iterating on directly to the
   production cluster, but this also has drawbacks.  Also, depending on what
   changes you'd like to experiment with, iteration on the live production
   system may not be possible due to the change control software preventing or
   automatically undoing the changes.  Specifically, if you want to iterate on
   changes for resources that have already been merged, you may find yourself
   working directly against the change control software, which would be actively
   undoing your changes as you attempt to make them!  In these cases, you may
   need to create an entirely separate deployment of your resources just to have
   something to iterate on.

#### 1 - Staging, Patch Files, and the main Branch

The spack infrastructure repository has a number of key branches that serve
different purposes.  First among these is the `main` branch.  This branch
contains the latest head of development and is the branch that most pull
requests will be made against.  The overall change control process starts with
these pull requests.  Most contributors will only need to interact with this
branch.

Among the files in the repository are a number of special config maps
representing "staged resources" - resources that are deployed for staging
purposes.  Such resources are automatically deployed from the `main` branch and
updated when new commits are merged to the `main` branch.

#### 2 - Production and Maintenance Windows

The contents of the `production` branch represent the resources that are
deployed and managed for production services.  The `production` branch typically
lags behind the `main` branch and is periodically brought up-to-date with the
`main` branch.  Generally, only cluster administrators and maintainers will need
to interact with this branch.  In general, these pushes to `production` are done
during a maintenance window - a predetermined window of time within which
production services may become unavailable.  While there are no formal service
level agreements for the production services, the regularly-scheduled
maintenance window affords us the option to perform service-disrupting
maintanenace work within a specific period of time while providing service
availability on a best-effort basis outside of that period.  Currently, the
maintenance windows occur on the first and third Friday of every month, starting
on midnight, eastern time, on that Friday and ending on midnight, eastern time,
the next day.

#### 3 - The flux Branch

The `flux` branch is a branch that is automatically managed by middleware
running on the cluster.  Its contents represent the exact resources that are
provisioned on the cluster at any given time and are automatically generated by
combining the contents of the `main` and `production` branches for staged and
production resources, respectively.  You would generally not open a pull request
against or interact with this branch.

#### 4 - Change Control Process Outline

 1. One or more pull requests are opened against the `main` branch and
    eventually merged.

    - The contents of these pull requests are iterated on through some
      combination of local and live experimentation.

    - Depending on the nature of the changes and the need for iteration, it is
      not unusual for these pull requests to remain open and unmerged for long
      periods of time.  Only when the author feels that the work has reached a
      stable state against which they'd like changes to be controlled do they
      indicate that the PR is ready for review and the PR is eventually merged.

 2. The state of the `production` branch is modified during a maintenance
    window.

    - First, a new pull request that brings `production` up-to-date with `main`
      is opened and merged.

    - Cluster middleware triggers changes to the `flux` branch.

    - Cluster middleware responds to changes in the `flux` branch by updating
      cluster resources.

    - The state of the cluster and services are reviewed for proper operation.

 3. If there are any issues that arise as a result of step 2, then remedial
    action is taken.

    - Depending on the nature of the issues, one or more "hotfix" pull requests
      are made directly against `production`.  These changes are made in an
      attempt to bring the cluster and services to a state of proper operation.

    - If attempts to "hotfix" the issues are ultimately successful, then another
      pull request that brings `main` up-to-date with `production` is made and
      merged.  i.e.: The "hotfix" changes are back-ported to `main`.

    - At any point during this process, the decision may be made to cancel the
      maintenance update, altogether, and roll it back.  If this decision is
      made, then a non-fast-forward update is force-pushed to the `production`
      branch, removing all commits added to it since step 2.  At this point, the
      process returns to step 1, and the update to `production` is postponed
      until more changes are merged to `main` (changes that should, hopefully,
      address the issues encountered during the aborted update).  Depending on
      how long it takes to make these new changes, the update may need to be
      postponed to a later maintenance window.
